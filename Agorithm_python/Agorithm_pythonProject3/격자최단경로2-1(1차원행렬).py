# 가장 왼쪽 열은 열 1이고 가장 오른쪽 열은 열 이다. 셀 는 번째 행과 번째 열의 셀을 나타낸다.
# 각 셀 에는 비용 이 주어진다. 아래 그림은  격자 예를 보여준다. 여기서  C(1,1)= 2, ..., C(4,5) = 8이다.

# 2-1) 셀 (1,1)에서 오른쪽 방향 혹은 아래쪽 방향으로만 가면서
# 셀 까지 가는 서로 다른 경로의 개수를 구하는 프로그램을 동적계획법을 이용하여 작성하시오.
# 경로의 개수를 9999999로 나눈 나머지를 출력한다.
def mngrid_solution(m, n):  # m*n격자 경로 개수 출력 함수
    if 1 <= m and n <=2000:
        grd = [0 for _ in range(((n+1)*(m+1)))]   # m*n격자를 생성함 각 셀의 값은 0

        for i in range((m+1)*(n+1)):   # for 구문을 m 과 n을 검사함
            if i == 1:   #  i = 1과 j = 1 일 경우 격자[1][1] 의 값은 1
                grd[i] = 1
            elif i%(n+1) == 0:
                continue
            else:    # 행과 열이 1이 아닐 경우
                grd[i] = grd[i - 1] + grd[i-(n+1)]  # 부분문제 최적 해 값(목적함수)의 재귀적 정의

        return grd[m*(n+1)-1] % 9999999   # 경로의 개수를 9999999로 나눈 나머지 출력


m, n = map(int, input().split())  # m*n격자 행과 열을 입력받음
print(mngrid_solution(m, n))
'''
4 5
'''